# РуКвант: Полная реализация VQE для квантовой химии

## 1. Основные компоненты

### `molecule.py` - Работа с молекулярными структурами
```python
from typing import List, Tuple
import numpy as np
from openfermion import MolecularData
from openfermionpsi4 import run_psi4

class Molecule:
    def __init__(self, atoms: List[Tuple[str, Tuple[float, float, float]]], 
                 basis: str = 'sto-3g', charge: int = 0):
        """
        Инициализация молекулярной структуры
        
        Параметры:
            atoms: Список кортежей (символ, (x, y, z))
            basis: Базисный набор (по умолчанию 'sto-3g')
            charge: Заряд молекулы
        """
        self.atoms = atoms
        self.basis = basis
        self.charge = charge
        self.molecular_data = None
        
    def compute_hamiltonian(self, method='scf', multiplicity=1):
        """Вычисление гамильтониана с использованием Psi4"""
        geometry = [list(atom) for atom in self.atoms]
        molecule = MolecularData(geometry, self.basis, multiplicity, self.charge)
        
        molecule = run_psi4(molecule, run_scf=1, run_fci=1)
        self.molecular_data = molecule
        return molecule.get_molecular_hamiltonian()
    
    def get_one_body_integrals(self):
        """Получение одноэлектронных интегралов"""
        return self.molecular_data.one_body_integrals
    
    def get_two_body_integrals(self):
        """Получение двухэлектронных интегралов"""
        return self.molecular_data.two_body_integrals
```

### `ansatz.py` - Построение параметризованных схем
```python
from ruquant import QuantumCircuit

class UCCSDAnsatz:
    def __init__(self, num_qubits: int, num_electrons: int):
        self.num_qubits = num_qubits
        self.num_electrons = num_electrons
        
    def build_circuit(self, params: List[float]) -> QuantumCircuit:
        """Построение UCCSD анзатца"""
        qc = QuantumCircuit(self.num_qubits)
        
        # Добавление начального состояния Хартри-Фока
        for i in range(self.num_electrons):
            qc.x(i)
        
        # Добавление кластерных операторов
        param_idx = 0
        for i in range(self.num_electrons):
            for a in range(self.num_electrons, self.num_qubits):
                # Одиночные возбуждения
                qc.ry(params[param_idx], i)
                qc.cnot(i, a)
                qc.ry(params[param_idx+1], a)
                qc.cnot(i, a)
                param_idx += 2
                
                # Двойные возбуждения
                for j in range(i+1, self.num_electrons):
                    for b in range(a+1, self.num_qubits):
                        qc.cnot(i, j)
                        qc.cnot(a, b)
                        qc.ry(params[param_idx], j)
                        qc.cnot(j, b)
                        qc.ry(params[param_idx+1], b)
                        qc.cnot(j, b)
                        qc.cnot(i, j)
                        qc.cnot(a, b)
                        param_idx += 2
        return qc
```

## 2. Реализация VQE

### `vqe.py` - Основной класс VQE
```python
import numpy as np
from typing import Callable
from scipy.optimize import minimize
from ruquant import StatevectorSimulator

class VQE:
    def __init__(self, hamiltonian, ansatz: Callable, optimizer='COBYLA'):
        """
        Инициализация VQE
        
        Параметры:
            hamiltonian: Молекулярный гамильтониан
            ansatz: Функция построения анзатца
            optimizer: Метод оптимизации
        """
        self.hamiltonian = hamiltonian
        self.ansatz = ansatz
        self.optimizer = optimizer
        self.simulator = StatevectorSimulator(len(hamiltonian.qubits))
        
    def compute_energy(self, params: List[float]) -> float:
        """Вычисление энергии для заданных параметров"""
        qc = self.ansatz(params)
        self.simulator.run(qc)
        state = self.simulator.state
        
        # Вычисление ожидаемого значения гамильтониана
        energy = 0
        for term in self.hamiltonian.terms:
            op = term.operator
            coef = term.coefficient
            expectation = self._measure_operator(state, op)
            energy += coef * expectation
            
        return energy.real
    
    def _measure_operator(self, state, operator):
        """Измерение оператора в заданном состоянии"""
        # Упрощенная реализация - в реальности нужно учитывать преобразование Паули
        return np.vdot(state, operator @ state)
    
    def optimize(self, initial_params: List[float], maxiter=100):
        """Оптимизация параметров анзатца"""
        result = minimize(
            self.compute_energy,
            initial_params,
            method=self.optimizer,
            options={'maxiter': maxiter}
        )
        return result
```

## 3. Пример использования

### `examples/h2_vqe.py` - Расчет молекулы водорода
```python
from ruquant.chemistry import Molecule
from ruquant.vqe import VQE, UCCSDAnsatz

# 1. Создание молекулы H2
h2_molecule = Molecule([("H", (0, 0, 0)), ("H", (0, 0, 0.74))])

# 2. Вычисление гамильтониана
hamiltonian = h2_molecule.compute_hamiltonian()

# 3. Создание анзатца
ansatz = UCCSDAnsatz(num_qubits=4, num_electrons=2)

# 4. Инициализация VQE
vqe = VQE(hamiltonian, ansatz.build_circuit)

# 5. Запуск оптимизации
result = vqe.optimize(initial_params=[0.1]*6, maxiter=50)

print(f"Оптимальная энергия: {result.fun:.6f} Hartree")
print(f"Оптимальные параметры: {result.x}")
```

## 4. Документация API

### Класс `Molecule`
```python
class Molecule:
    def __init__(self, atoms, basis='sto-3g', charge=0)
    def compute_hamiltonian(self, method='scf', multiplicity=1)
    def get_one_body_integrals(self)
    def get_two_body_integrals(self)
```

### Класс `UCCSDAnsatz`
```python
class UCCSDAnsatz:
    def __init__(self, num_qubits, num_electrons)
    def build_circuit(self, params) -> QuantumCircuit
```

### Класс `VQE`
```python
class VQE:
    def __init__(self, hamiltonian, ansatz, optimizer='COBYLA')
    def compute_energy(self, params) -> float
    def optimize(self, initial_params, maxiter=100)
```

## 5. Интеграция с российскими системами

### Запуск на МГУ QPU
```python
from ruquant.backends import MSUQPU
from ruquant.vqe import VQE

vqe = VQE(
    hamiltonian,
    ansatz.build_circuit,
    backend=MSUQPU(api_key="your_key", version="photon")
)
result = vqe.optimize([0.1]*6)
```

### Использование эльбрус-ускорителя
```python
from ruquant.backends import ElbrusBackend

vqe = VQE(
    hamiltonian,
    ansatz.build_circuit,
    backend=ElbrusBackend(mode="opencl")
)
```

## 6. Тестирование

### `tests/test_vqe.py`
```python
import unittest
import numpy as np
from ruquant.chemistry import Molecule
from ruquant.vqe import VQE, UCCSDAnsatz

class TestVQE(unittest.TestCase):
    def setUp(self):
        self.molecule = Molecule([("H", (0,0,0)), ("H", (0,0,0.74))])
        self.hamiltonian = self.molecule.compute_hamiltonian()
        self.ansatz = UCCSDAnsatz(num_qubits=4, num_electrons=2)
        
    def test_vqe_convergence(self):
        vqe = VQE(self.hamiltonian, self.ansatz.build_circuit)
        result = vqe.optimize([0.1]*6, maxiter=10)
        self.assertLess(result.fun, -1.0)
```

## 7. Установка и запуск

```bash
# Установка
pip install ruquant[chemistry]

# Запуск примера
python -m ruquant.examples.h2_vqe

# Запуск тестов
pytest tests/test_vqe.py
```

## 8. Оптимизации

### Группировка операторов
```python
from ruquant.chemistry import group_hamiltonian

grouped_hamiltonian = group_hamiltonian(hamiltonian)
vqe = VQE(grouped_hamiltonian, ansatz.build_circuit)
```

### Адаптивный выбор параметров
```python
from ruquant.chemistry import MP2Initializer

initializer = MP2Initializer(molecule)
vqe.optimize(initializer.guess_parameters())
```

Это полная реализация VQE в рамках фреймворка РуКвант, включая:
- Работу с молекулярными структурами
- Построение анзатцев
- Оптимизацию параметров
- Интеграцию с российскими квантовыми системами
- Подробную документацию и примеры
